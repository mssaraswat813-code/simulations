<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bouncing Balls Simulation</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    #controls {
      margin: 10px;
    }
    canvas {
      background: #222;
      border: 2px solid #555;
      border-radius: 8px;
      display: block;
    }
    button, input {
      margin: 5px;
    }
  </style>
</head>
<body>
  <h2>Bouncing Balls with Real Physics</h2>
  <div id="controls">
    Gravity: <input type="range" id="gravitySlider" min="0" max="1" step="0.05" value="0.3"> 
    <span id="gravityValue">0.3</span>
    Ball Weight: <input type="number" id="weightInput" min="1" max="10" value="5">
    <button id="addBall">Add Ball</button>
    <button id="clearBalls">Clear Balls</button>
	  <a href="index.html"><button> manu</button> </a> 
  </div>
  <canvas id="canvas" width="600" height="400"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const gravitySlider = document.getElementById("gravitySlider");
    const gravityValue = document.getElementById("gravityValue");
    const weightInput = document.getElementById("weightInput");
    const addBallBtn = document.getElementById("addBall");
    const clearBallsBtn = document.getElementById("clearBalls");

    let balls = [];
    let gravity = parseFloat(gravitySlider.value);

    class Ball {
      constructor(x, y, radius, mass) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.radius = radius;
        this.mass = mass;
        this.color = `hsl(${Math.random()*360}, 70%, 50%)`;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
      update() {
        this.vy += gravity;
        this.x += this.vx;
        this.y += this.vy;

        // wall collisions
        if (this.x - this.radius < 0) {
          this.x = this.radius;
          this.vx *= -1;
        }
        if (this.x + this.radius > canvas.width) {
          this.x = canvas.width - this.radius;
          this.vx *= -1;
        }
        if (this.y - this.radius < 0) {
          this.y = this.radius;
          this.vy *= -1;
        }
        if (this.y + this.radius > canvas.height) {
          this.y = canvas.height - this.radius;
          this.vy *= -1;
        }
      }
    }

    function resolveCollision(b1, b2) {
      const dx = b2.x - b1.x;
      const dy = b2.y - b1.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < b1.radius + b2.radius) {
        // unit normal & tangent vectors
        const nx = dx / dist;
        const ny = dy / dist;
        const tx = -ny;
        const ty = nx;

        // velocities in normal & tangent direction
        const dpTan1 = b1.vx * tx + b1.vy * ty;
        const dpTan2 = b2.vx * tx + b2.vy * ty;

        const dpNorm1 = b1.vx * nx + b1.vy * ny;
        const dpNorm2 = b2.vx * nx + b2.vy * ny;

        // 1D elastic collision equations for normal velocities
        const m1 = b1.mass;
        const m2 = b2.mass;
        const v1 = (dpNorm1 * (m1 - m2) + 2 * m2 * dpNorm2) / (m1 + m2);
        const v2 = (dpNorm2 * (m2 - m1) + 2 * m1 * dpNorm1) / (m1 + m2);

        // update velocities
        b1.vx = tx * dpTan1 + nx * v1;
        b1.vy = ty * dpTan1 + ny * v1;
        b2.vx = tx * dpTan2 + nx * v2;
        b2.vy = ty * dpTan2 + ny * v2;

        // prevent overlap (push balls apart)
        const overlap = (b1.radius + b2.radius - dist) / 2;
        b1.x -= overlap * nx;
        b1.y -= overlap * ny;
        b2.x += overlap * nx;
        b2.y += overlap * ny;
      }
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < balls.length; i++) {
        balls[i].update();
        balls[i].draw();
        for (let j = i + 1; j < balls.length; j++) {
          resolveCollision(balls[i], balls[j]);
        }
      }
      requestAnimationFrame(animate);
    }

    // UI events
    gravitySlider.addEventListener("input", () => {
      gravity = parseFloat(gravitySlider.value);
      gravityValue.textContent = gravity;
    });

    addBallBtn.addEventListener("click", () => {
      let mass = parseFloat(weightInput.value);
      let radius = 10 + mass * 2;
      balls.push(new Ball(Math.random() * canvas.width, Math.random() * canvas.height, radius, mass));
    });

    clearBallsBtn.addEventListener("click", () => {
      balls = [];
    });

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      let mass = parseFloat(weightInput.value);
      let radius = 10 + mass * 2;
      balls.push(new Ball(x, y, radius, mass));
    });

    animate();
  </script>
</body>
</html>
